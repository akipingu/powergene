---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```


# powergene: A generalizable simulation-based power analysis R package for semi-field vector control trials


<!-- badges: start -->

<!-- badges: end -->

The powergene R package simulates mosquito count data under short- and long-term semi-field experimental design scenarios, evaluating single or combined interventions. It incorporates fixed treatment effects, random chamber-level or sampling time-level variability to support robust power analysis for short- or long-term semi-field experimental planning. 

This package is an extension of a simulation based power analysis framework developed by [Kipingu et. al 2025](https://doi.org/10.1186/s12936-025-05454-y
). Therefore, all parameter values for the examples below are taken directly from the same study. Visit [Kipingu et al. 2025](https://doi.org/10.1186/s12936-025-05454-y) or [Johnson et al. 2014](https://doi.org/10.1111/2041-210X.12306) for more information and description regarding simulation-based power analysis.



## Installation of powergene package

You can install the development version of powergene package directly from
[GitHub](https://github.com/) with:


```{r install-powergene, message=FALSE, warning=FALSE, results='hide'}
# # First, install.packages("devtools") if not already installed in your RStudio.

# -------------------------------
# Setup: install or load required packages
# -------------------------------

# List all CRAN packages your Rmd needs
required_cran <- c("rmarkdown", "knitr", "ggplot2", "dplyr", "tidyr", "remotes", "devtools")

# Install any missing CRAN packages
for (pkg in required_cran) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
        suppressMessages(suppressWarnings(
    install.packages(pkg, repos = "https://cloud.r-project.org")
  ))
  }
}

# Load CRAN packages
lapply(required_cran, library, character.only = TRUE)

# Install 'powergene' from GitHub if not already installed
if (!requireNamespace("powergene", quietly = TRUE)) {
  devtools::install_github("akipingu/powergene")
}

# Load 'powergene' package
library(powergene)
```

If you use **powergene** in your research or publications, please cite it appropriately
```{r}
#cite this package
citation("powergene")
```



## Example I: Estimating power of a short-term SFE testing single intervention

This is a basic example which shows you how to apply the powergene package to estimate power of a short-term SFE

I. Simulate a table of scenarios based on number of chamber per treatment provided, e.g., n.ch.per.trt=4. After specifying number of chamber per each treatment (control vs. intervention), the function sim.scen.shortsfe.sinint will output three columns including number of chambers per each treatment (replicates), treatment status as intvn (0 for control and 1 for intervention) and id for each individual chamber/replicate.

```{r}
scen.table <- sim.scen.shortsfe.sinint(n.ch.per.trt = 4)

#print a scenario table
scen.table
```


II. Simulate mosquitoes counts/abundance by specifying the number of chambers per treatment, e.g., n.ch.per.trt = 4, expected mosquitoes to be recaptured from a control chamber, e.g., lambda=50, intervention effect, e.g., intvn.effect = 0.8 for 80% effect, and chamber-level variance, e.g., chamber.var = 0.1807. The resultant number of mosquitoes will be either with random effect included or without including the random effect. Below, columns 4, 5 and 6 because they are optional but you can print them if you want. Remember our main target is the mosquito abundance that account for chamber random effect. The use.random has four options to output mosquito count column either with the use of random effect (TRUE), fixed effect only (FALSE), only fixed effect from exponential function rather than from a known statistical distribution (NULL) or all mosquito count columns ("ALL"). Below I set use.random = "ALL" as an example.

```{r}
sim.mosquitoes <- sim.mosq.shortsfe.sinint(
  n.ch.per.trt = 4,
  lambda = 50,
  intvn.effect = 0.8,
  chamber.var = 0.1807,
  use.random = "ALL"
)
#output mosquito counts per each chamber per each treatment
sim.mosquitoes <- sim.mosquitoes[, c(-4,-5,-6)]
sim.mosquitoes
```

III. Plot the simulated mosquitoes. This function plots a box plot with an option to jitter points if jitter=TURE and without jittering if jitter=FALSE. The use.random option is also used in this function with only TRUE, FALSE or NULL as explained in (2) above

```{r}
sim.plot.shortsfe.sinint(
  n.ch.per.trt = 4,
  lambda = 50,
  intvn.effect = 0.8,
  chamber.var = 0.1807,
  use.random = TRUE,
  jitter = TRUE
)
```


IV. Estimate p-value using sim.pval.shortsfe.sinint function by specifying the number of chambers per treatment, e.g., n.ch.per.trt = 4, expected mosquitoes to be recaptured from a control chamber, e.g., lambda=50, intervention effect, e.g., intvn.effect = 0.8 for 80% effect, and chamber-level variance, e.g., chamber.var = 0.1807. The p-value estimation is based on mosquito abundance that accounted for random chamber effect. The use.random option is also used in this function with only TRUE or FALSE as explained in (ii) above

```{r}
pvalue <- sim.pval.shortsfe.sinint(
    n.ch.per.trt = 4,
  lambda = 50,
  intvn.effect = 0.8,
  chamber.var = 0.1807,
  use.random = TRUE
)

#output the p-values
pvalue
```



V. Since power cannot be estimated from a single simulation, there is a need to simulate multiple data sets and estimate power. Now you can estimate power by specifying the number of chambers per treatment, e.g., n.ch.per.trt = 4, expected mosquitoes to be recaptured from a control chamber, e.g., lambda=50, intervention effect, e.g., intvn.effect = 0.8 for 80% effect, chamber-level variance, e.g., chamber.var = 0.1807, and the total simulations, e.g., nsim=100. A 100 simulations are just for illustration purpose, but it is recommended to run at least 1000 simulations if you are estimating power for a real experiment. The power estimation is based on mosquito abundance that accounted for random chamber effect. The use.random option is also used in this function with only TRUE or FALSE as explained in (ii) above.

```{r}
power.estimate <- sim.power.shortsfe.sinint(n.ch.per.trt = 4,
  lambda = 50,
  intvn.effect = 0.8,
  chamber.var = 0.1807, 
  nsim = 100,
  use.random = TRUE
  )

#print estimated power
round(power.estimate,2)
```

VI. Now you use the function to estimate power for varied number of chambers per treatment, e.g., 2,4,6,8. You can repeat this stage for all the power estimation functions in the package. Note that, this step is not necessary but we are showing it here to demonstrate the robustness of the package.

```{r}
# Define treatment sizes
n.ch.values <- c(2, 4, 6, 8)

# Initialize storage
power.df <- data.frame(
  n.ch.per.trt = n.ch.values,
  power = NA,
  ci.lower = NA,
  ci.upper = NA
)

# Run simulations and extract power + confidence intervals
for (i in seq_along(n.ch.values)) {
  n <- n.ch.values[i]
  
  result <- sim.power.shortsfe.sinint(
    n.ch.per.trt = n,
    lambda = 50,
    intvn.effect = 0.8,
    chamber.var = 0.1807,
    nsim = 100,
    use.random = TRUE
  )
  
  # Store results
  power.df$power[i] <- result["power"]
  power.df$ci.lower[i] <- result["ci.lower"]
  power.df$ci.upper[i] <- result["ci.upper"]
}

#print the power results for each number of chambers per treatment
round(power.df,2)
```

VII. Plot the resulting power vs. number of chambers per treatment

```{r}
# install.packages("ggplot2") if not yet installed
library(ggplot2)

ggplot(power.df, aes(x = n.ch.per.trt, y = power)) +
  geom_point(color = "black", size = 2) +
  geom_line(color = "black", linewidth = 0.4) +
  geom_errorbar(aes(ymin = ci.lower, ymax = ci.upper),
                width = 0.4, color = "black", linewidth = 0.4) +
  labs(
    x = "Number of chambers per treatment",
    y = "Estimated power",
    title = "Power vs. number of chambers per treatment with 95% CI"
  ) +
  scale_y_continuous(labels = scales::percent, limit=c(0,1), breaks=seq(0,1,0.2)) +
  geom_hline(yintercept=0.8, lty="twodash") +
  geom_hline(yintercept=0.05, lty="longdash") +  
  theme_bw()
```

VIII. Now you can use the function to estimate power for varied number of chambers per treatment, e.g., 2,4,6,8 and varied effect size of an intervention. You can repeat this stage for all the power estimation functions in the package. Note that, this step is not necessary but we are showing it here to demonstrate the robustness of the package.

```{r}
# Define parameter grids
n.ch.values <- c(2, 4, 6, 8)
effect.sizes <- c(0, 0.4, 0.5, 0.6, 0.8)

# Initialize results storage
results <- expand.grid(
  n.ch.per.trt = n.ch.values,
  intvn.effect = effect.sizes
)
results$power <- NA
results$ci.lower <- NA
results$ci.upper <- NA

# Loop over combinations
for (i in seq_len(nrow(results))) {
  row <- results[i, ]
  
  sim <- sim.power.shortsfe.sinint(
    n.ch.per.trt = row$n.ch.per.trt,
    lambda = 50,
    intvn.effect = row$intvn.effect,
    chamber.var = 0.1807,
    nsim = 100,
    TRUE
  )
  
  results$power[i] <- sim["power"]
  results$ci.lower[i] <- sim["ci.lower"]
  results$ci.upper[i] <- sim["ci.upper"]
}
# print power estimates
results
```

IX. Now plot the resulting power estimates vs. number of chambers per treatment or effect sizes.

```{r}
# install.packages("ggplot2") if not yet installed
library(ggplot2)
results$intvn.effect <- factor(results$intvn.effect, levels = sort(unique(results$intvn.effect), decreasing = TRUE))
ggplot(results, aes(x = n.ch.per.trt, y = power, color = factor(intvn.effect), group = intvn.effect)) +
  geom_point(size = 2) +
  geom_line(linewidth = 0.8) +
  geom_errorbar(aes(ymin = ci.lower, ymax = ci.upper),
                width = 0.3, linewidth = 0.6) +
  geom_hline(yintercept = 0.8, linetype = "twodash", color = "gray50") +
  geom_hline(yintercept = 0.05, linetype = "longdash", color = "gray50") +
  scale_y_continuous(labels = scales::percent, limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
  scale_color_brewer(palette = "Dark2", name = "Effect size \n(% reduction)",
                       labels = function(x) as.character(as.numeric(x) * 100)) +
  labs(
    x = "Number of chambers per treatment",
    y = "Estimated power",
    title = "Power vs. number of chamber per treatment by intervention effect Size"
  ) +
  theme_bw()
```


## Example II: Estimating power of a short-term SFE testing combined interventions

Since we have demonstrated all steps for power estimation in Example I, in this example we will demonstrate only few steps. Note that, to estimate power you only need one function called "sim.power.shortsfe.comint()". However, for learning purpose we demonstrate how other functions work as shown below.

Notes: In this case study, we considered number of chambers per treatment (“n.ch.per.trt”), which can be 4; number of recaptured mosquitoes (“lambda”), which can be 50; effect of intervention 1 alone “intvn1.effect”, which is 0.7; effect of intervention 2 alone “intvn2.effect”, which is 0.8; interaction effect between intvn1 and intvn2 (“ixn.effect”), which can be  0.5; inter-chamber variance (“chamber.var”), which can be 0.1807; and total number of simulations (“nsim”), which is 100 for demonstration, but we suggest at least 1000 simulation. 

Notes: Some functions has options where you can simulate or plot mosquitoes and estimate p-values or power while utilizing the "use.random" input. You can simulate or plot mosquitoes and estimate p-values or power while taking into account random effects using "use.random = TRUE", fixed effect only  using "use.random = FALSE", exponential function using "use.random = NULL", or all options using 'use.random = "ALL"'. Note that, "use.random = NULL" and 'use.random = "ALL"' only works for simulating or plotting mosquitoes. This applies for all functions throughout the package, except those simulating scenario tables.

I. Simulate scenario table for SFE testing combined interventions. For more information on each input below, type "?sim.scen.shortsfe.comint" in RStudio

```{r}
scen.table <- sim.scen.shortsfe.comint(n.ch.per.trt = 4)
#print a scenario table
#scen.table
```


II. Simulate mosquitoes counts/abundance for SFE testing combined interventions. For more information on each input below, type "?sim.mosq.shortsfe.comint" in RStudio. 

```{r}
# You can simulate mosquitoes accounting for random effects using "use.random = TRUE".
# You can simulate mosquitoes accounting for  fixed effect using "use.random = FALSE".
# You can simulate mosquitoes from exponential function using "use.random = NULL".
# You can simulate mosquitoes for all options above using 'use.random = "ALL"'.
sim.mosq.shortsfe.comint(
  n.ch.per.trt = 4,
  lambda = 50,
  intvn1.effect = 0.7,
  intvn2.effect = 0.8,
  ixn.effect = 0.5,
  chamber.var = 0.1807,
  use.random = "ALL"
)
```


III. Plot mosquitoes counts/abundance for SFE testing combined interventions. For more information on each input below, type "?sim.plot.shortsfe.comint" in RStudio

```{r}
# Plot mosquitoes with random effects using "use.random = TRUE".
# You can also plot with fixed effect using "use.random = FALSE".
# You can also plot mosquito exponential function using "use.random = NULL".
plot_mosquitoes <- sim.plot.shortsfe.comint(
  n.ch.per.trt = 4,
  lambda = 50,
  intvn1.effect = 0.7,
  intvn2.effect = 0.8,
  ixn.effect = 0.5,
  chamber.var = 0.1807,
  use.random = TRUE,
  jitter = TRUE
)
```


IV. Estimate p-values from mosquitoes counts/abundance data for SFE testing combined interventions. For more information on each input below, type "?sim.pval.shortsfe.comint" in RStudio

```{r}
# Estimate p-value, account for random effects using "use.random = TRUE".
# Estimate p-value, account for fixed effect only using "use.random = FALSE".
pvalue_est <- sim.pval.shortsfe.comint(
  n.ch.per.trt = 4,
  lambda = 50,
  intvn1.effect = 0.7,
  intvn2.effect = 0.8,
  ixn.effect = 0.5,
  chamber.var = 0.1807,
  use.random = TRUE
)
```


V. Estimate power for SFE testing combined interventions. For more information on each input below, type "?sim.power.shortsfe.comint" in RStudio. If you computer has multiple cores, you can specify what amount of core you want to utilise using "n.cores"; if not, just use "n.cores = 1" as default. You may even decide to remove n.cores if you don't want to use it. 
```{r}
# Estimate p-value, account for random effects using "use.random = TRUE".
# Estimate p-value, account for fixed effect only using "use.random = FALSE".
power_est <- sim.power.shortsfe.comint(
  n.ch.per.trt = 4,
  lambda = 50,
  intvn1.effect = 0.7,
  intvn2.effect = 0.8,
  ixn.effect = 0.5,
  chamber.var = 0.1807,
  nsim = 100,
  n.cores = 1,
  use.random = TRUE
)
```




## Example III: Estimating power of a long-term SFE testing single intervention

Again, since we have demonstrated all steps for power estimation in Example I, in this example we will demonstrate only few steps. Note that, to estimate power for long-term SFE testing single intervention, you only need to apply one function called "sim.power.longsfe.sinint()". However, for learning purpose we demonstrate how other functions work as shown below.

Notes: In this case, we consider number of chambers per treatment (“n.ch.per.trt”), e.g., 4; length of experiment ("exp.length"), which specify the length of experiment in days, e.g., a 3 months experiments has a length of 90 days; frequency of sampling ("sampl.freq”), which means how often will you be sampling adult mosquitoes, e.g., "weekly" sampling for a 3 months experiment means you sample adult mosquitoes only 12 times.; number of mosquitoes to be sampled (“lambda”), e.g., 10; intervention effect over time ("intvn.effect"), e.g., 0.8; inter-chamber variance (“chamber.var”), e.g., 0.1807; time variance (“time.var), e.g., 0.2266; dispersion parameter (“theta”), e.g., 10; and total number of simulations (“nsim”), e.g., 100 for demonstration, but we suggest using at least 1000 simulations. 

I. Simulate scenario table for a long-term SFE testing single intervention. For more information on each input below, type "?sim.scen.longsfe.sinint" in RStudio.

```{r}
scen.table <- sim.scen.longsfe.sinint(
n.ch.per.trt = 4,
exp.length = 90,
sampl.freq = "weekly"
)
#print a scenario table
#scen.table
```


II. Simulate mosquitoes counts/abundance for a long-term SFE testing single intervention. For more information on each input below, type "?sim.mosq.longsfe.sinint" in RStudio

```{r}
# You can simulate mosquitoes accounting for random effects using "use.random = TRUE".
# You can simulate mosquitoes accounting for  fixed effect using "use.random = FALSE".
# You can simulate mosquitoes from exponential function using "use.random = NULL".
# You can simulate mosquitoes for all options above using 'use.random = "ALL"'.
sim_mosq <- sim.mosq.longsfe.sinint(
  n.ch.per.trt = 4,
  exp.length = 90,
  sampl.freq = "weekly",
  lambda = 10,
  intvn.effect = 0.8,
  chamber.var = 0.1807,
  time.var = 0.2266,
  theta = 10,
  use.random = "ALL"
)
```


III. Plot mosquitoes counts/abundance for long-term SFE testing single intervention. For more information on each input below, type "?sim.plot.longsfe.sinint" in RStudio

```{r}
# You can plot mosquitoes with random effects using "use.random = TRUE".
plot_mosq1 <- sim.plot.longsfe.sinint(
  n.ch.per.trt = 4,
  exp.length = 90,
  sampl.freq = "weekly",
  lambda = 10,
  intvn.effect = 0.8,
  chamber.var = 0.1807,
  time.var = 0.2266,
  theta = 10,
  use.random = TRUE
)
plot_mosq1

# You can also plot with fixed effect using "use.random = FALSE".
plot_mosq2 <- sim.plot.longsfe.sinint(
  n.ch.per.trt = 4,
  exp.length = 90,
  sampl.freq = "weekly",
  lambda = 10,
  intvn.effect = 0.8,
  chamber.var = 0.1807,
  time.var = 0.2266,
  theta = 10,
  use.random = FALSE
)
plot_mosq2

# You can also plot mosquito from exponential function using "use.random = NULL".
plot_mosq3 <- sim.plot.longsfe.sinint(
  n.ch.per.trt = 4,
  exp.length = 90,
  sampl.freq = "weekly",
  lambda = 10,
  intvn.effect = 0.8,
  chamber.var = 0.1807,
  time.var = 0.2266,
  theta = 10,
  use.random = NULL
)
plot_mosq3
```


IV. Estimate p-values from mosquitoes counts/abundance data for long-term SFE testing single intervention. For more information on each input below, type "?sim.pval.longsfe.sinint" in RStudio

```{r}
# Estimate p-value, account for random effects using "use.random = TRUE".
# Estimate p-value, account for fixed effect only using "use.random = FALSE".
pvalue_est <- sim.pval.longsfe.sinint(
  n.ch.per.trt = 4,
  exp.length = 90,
  sampl.freq = "weekly",
  lambda = 10,
  intvn.effect = 0.8,
  chamber.var = 0.1807,
  time.var = 0.2266,
  theta = 10,
  use.random = TRUE
)
```


V. Estimate power for long-term SFE testing single intervention. For more information on each input below, type "?sim.power.longsfe.sinint" in RStudio. If you computer has multiple cores, you can specify what amount of core you want to utilise using "n.cores"; if not, just use "n.cores = 1" as default. You may even decide to remove n.cores if you don't want to use it. 
```{r}
# Estimate p-value, account for random effects using "use.random = TRUE".
# Estimate p-value, account for fixed effect only using "use.random = FALSE".
power_est <- sim.power.longsfe.sinint(
  n.ch.per.trt = 4,
  exp.length = 90,
  sampl.freq = "weekly",
  lambda = 10,
  intvn.effect = 0.8,
  chamber.var = 0.1807,
  time.var = 0.2266,
  theta = 10,
  nsim = 100,
  n.cores = 1,
  use.random = TRUE
)
```





## Example IV: Estimating power of a long-term SFE testing combined interventions

Again, since we have demonstrated all steps for power estimation in Example I, in this example we will demonstrate only few steps. Note that, to estimate power for long-term SFE testing combined interventions, you only need to apply one function called "sim.power.longsfe.comint()". However, for learning purpose we demonstrate how other functions work as shown below.

Notes: In this case, we consider intervention 1 effect over time ("intvn1.effect"), e.g., 0.7; intervention 2 effect over time ("intvn2.effect"), e.g., 0.8; interaction between intervention 1 and 2 ("ixn.effect"), e.g., 0.5; inter-chamber variance (“chamber.var”), e.g., 0.1807; time variance (“time.var), e.g., 0.2266; dispersion parameter (“theta”), e.g., 10; and total number of simulations (“nsim”), e.g., 100 for demonstration, but we suggest using at least 1000 simulations. 

I. Simulate scenario table for a long-term SFE testing combined interventions. For more information on each input below, type "?sim.scen.longsfe.comint" in RStudio.

```{r}
scen.table <- sim.scen.longsfe.comint(
  n.ch.per.trt = 4,
  exp.length = 90,
  sampl.freq = "weekly"
)
#print a scenario table
#scen.table
```


II. Simulate mosquitoes counts/abundance for a long-term SFE testing combined interventions. For more information on each input below, type "?sim.mosq.longsfe.comint" in RStudio

```{r}
# You can simulate mosquitoes accounting for random effects using "use.random = TRUE".
# You can simulate mosquitoes accounting for  fixed effect using "use.random = FALSE".
# You can simulate mosquitoes from exponential function using "use.random = NULL".
# You can simulate mosquitoes for all options above using 'use.random = "ALL"'.
sim_mosq <- sim.mosq.longsfe.comint(
  n.ch.per.trt = 4,
  exp.length = 90,
  sampl.freq = "weekly",
  lambda = 10,
  intvn1.effect = 0.7,
  intvn2.effect = 0.8,
  ixn.effect = 0.8,
  chamber.var = 0.1807,
  time.var = 0.2266,
  theta = 10,
  use.random = "ALL"
)
```


III. Plot mosquitoes counts/abundance for long-term SFE testing combined interventions. For more information on each input below, type "?sim.plot.longsfe.comint" in RStudio

```{r}
# Plot mosquitoes with random effects using "use.random = TRUE".
plot_mosq1 <- sim.plot.longsfe.comint(
  n.ch.per.trt = 4,
  exp.length = 90,
  sampl.freq = "weekly",
  lambda = 10,
  intvn1.effect = 0.7,
  intvn2.effect = 0.8,
  ixn.effect = 0.8,
  chamber.var = 0.1807,
  time.var = 0.2266,
  theta = 10,
  use.random = TRUE
)
plot_mosq1
# You can also plot with fixed effect using "use.random = FALSE".
plot_mosq2 <- sim.plot.longsfe.comint(
  n.ch.per.trt = 4,
  exp.length = 90,
  sampl.freq = "weekly",
  lambda = 10,
  intvn1.effect = 0.7,
  intvn2.effect = 0.8,
  ixn.effect = 0.8,
  chamber.var = 0.1807,
  time.var = 0.2266,
  theta = 10,
  use.random = FALSE
)
plot_mosq2
# You can also plot mosquito from exponential function using "use.random = NULL".
plot_mosq3 <- sim.plot.longsfe.comint(
  n.ch.per.trt = 4,
  exp.length = 90,
  sampl.freq = "weekly",
  lambda = 10,
  intvn1.effect = 0.7,
  intvn2.effect = 0.8,
  ixn.effect = 0.8,
  chamber.var = 0.1807,
  time.var = 0.2266,
  theta = 10,
  use.random = NULL
)
plot_mosq3
```


IV. Estimate p-values from mosquitoes counts/abundance data for long-term SFE testing combined interventions. For more information on each input below, type "?sim.pval.longsfe.comint" in RStudio

```{r}
# Estimate p-value, account for random effects using "use.random = TRUE".
# Estimate p-value, account for fixed effect only using "use.random = FALSE".
pvalue_est <- sim.pval.longsfe.comint(
  n.ch.per.trt = 4,
  exp.length = 90,
  sampl.freq = "weekly",
  lambda = 10,
  intvn1.effect = 0.7,
  intvn2.effect = 0.8,
  ixn.effect = 0.8,
  chamber.var = 0.1807,
  time.var = 0.2266,
  theta = 10,
  use.random = TRUE
)
```


V. Estimate power for long-term SFE testing combined interventions. For more information on each input below, type "?sim.power.longsfe.comint" in RStudio. If you computer has multiple cores, you can specify what amount of core you want to utilize using "n.cores"; if not, just use "n.cores = 1" as default. You may even decide to remove n.cores if you don't want to use it. 
```{r}
# Estimate p-value, account for random effects using "use.random = TRUE".
# Estimate p-value, account for fixed effect only using "use.random = FALSE".
power_est <- sim.power.longsfe.comint(
  n.ch.per.trt = 4,
  exp.length = 90,
  sampl.freq = "weekly",
  lambda = 10,
  intvn1.effect = 0.7,
  intvn2.effect = 0.8,
  ixn.effect = 0.8,
  chamber.var = 0.1807,
  time.var = 0.2266,
  theta = 10,
  nsim = 100,
  n.cores = 1,
  use.random = TRUE
)
```
