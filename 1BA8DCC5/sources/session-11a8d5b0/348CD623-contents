---
title: "A power analysis framework to design robust semi-field vector control experiments: \n Power analysis R tutorial for long-term SFE testing single intervention"
author: "Kipingu AM, Lwetoijera DW, Ng'habi K, Kiware SS, Viana M, Johnson PCD"
date: "`r Sys.Date()`"
output: html_document
fontsize: 12pt
---

Set libraries
```{r}
library(ggplot2) #for ggplot
library(lme4) #for glmer
library(dplyr) #case_when function
```

set seed
```{r}
# helps to give same result every time one run the code. You can choose to disable it
set.seed(123)  
```

Notes: Simulation of data sets consists of different experimental design scenarios intended to be test. In our case, we consider number of chambers per treatment (â€œn.ch.per.trtâ€), which is 4; frequency of sampling ("sampl.freqâ€), which is 12 corresponds to weekly sampling; number of mosquitoes to be sampled (â€œlambdaâ€), which is 10; proportion of mosquitoes remaining over time due to ITN â€œitn.time.effectâ€, which is 0.2; inter-chamber variance (â€œchamber.varâ€), which is 0.1807; time variance (â€œtime.var), which is 0.2266; dispersion parameter (â€œthetaâ€), which is 10; and total number of simulations (â€œnsimâ€), which is 100 for this tutorial. 

i) Set and assign an experimental design choices based on the number of chambers per treatment, sampling frequency and ITN intervention level. Make a template dataset called â€œdatâ€ representing the design. 

```{r}

# design choices
n.ch.per.trt <- 4
    sampl.freq <- 12
    itn.lev <- 0:1
    
    # make template data set representing design 
    dat <-
      expand.grid(replicates = 1:n.ch.per.trt, itn = itn.lev, time = (0:sampl.freq)/sampl.freq)
    dat$itn.time <- dat$itn*dat$time
    dat$chamber <- factor(paste(dat$itn, dat$replicates, sep = "-"))
    dat$timef <- factor(dat$time)
    # rearranging data set in a useful order
    dat <- dat[, c("replicates", "itn", "timef", "time", "chamber", "itn.time")]
    dat
```

Assign values for all parameters choices for fixed and random effects. The intervention (i.e., ITN) effect size here will be dynamic, which means changes with time. 

```{r}
    # mean catch mosquito count in control group
    lambda <- 40
    # proportions remaining due to ITN
    itn.effect <- 1 
    itn.time.effect <- 0.2 
    # assign chamber and time variances and dispersion parameter 
    chamber.var <- 1.807e-01
    # time variance/variability (in weeks) 
    time.var <- 2.266e-01
    # theta is a dispersion/variability parameter for negative binomial distribution 
    # measures how sample (i.e., mosquito counts in our case) fluctuates around the mean
    # theta is usually interpreted as a measure of overdispersion with respect to the Poisson distribution.       
    # the variance of the negative binomial is ğœ‡+ğœ‡2/ğœƒ, so ğœƒ really controls the excess variability compared to Poisson (which would be ğœ‡)
    theta <- 10
```

Calculate coefficients for all linear predictor terms using the log link function. We used the log link function because parameter of negative binomial distribution is non-negative. 

```{r}
    b.0 <- log(lambda)
    b.i <- log(itn.effect)
    b.i.t <- log(itn.time.effect)
```

ii)	Simulation of a single data set. 
As we have already set our experimental design scenarios and parameter choices such as coefficients for linear predictors, inter-chamber variance and the dispersion parameter value, now we can simulate a single data set. This means we will first simulate the values for the linear predictor that will then generate the mosquito counts that would be expected if faced with our experimental scenario and parameter choices. Here, we also simulate random effects between chambers as well as linear predictors without and with random effects. Using the simulated linear predictors, expected mosquito counts will then be generated using a negative binomial distribution.

```{r}
      # simulate random effects
      # random effect between chambers
      chamber.re <- rnorm(nlevels(dat$chamber), sd = sqrt(chamber.var))
      names(chamber.re) <- levels(dat$chamber)
      # random effect between time (e.g., between weeks)
      time.re <- rnorm(nlevels(dat$timef), sd = sqrt(time.var))
      names(time.re) <- levels(dat$timef)
      # simulate linear predictor (with fixed effects only)
      # add the simulated data to dataset "dat" as a column named lin.pred
      dat$lin.pred.fixed <-
        b.0 +  b.i * dat$itn + b.i.t*dat$itn.time 
      # add random effects (chamber.re and time.re) to linear predictors trials, mean and size
      dat$lin.pred <-
        dat$lin.pred.fixed +
        chamber.re[as.character(dat$chamber)] +
        time.re[as.character(dat$timef)]
      # generate mosquitoes counts as random data using negative binomial distribution with number of trials (total rows of "dat"), mean or mu (exponet of lin.pred) and size (theta) 
      dat$mosquito.count <- rnbinom(nrow(dat), mu = exp(dat$lin.pred), size = theta)
    # output the â€œdatâ€
    dat
```

iii)	Perform a statistical test for a simulated data set to extract the p-value. 

Fit the simulated data to the GLMM model using a glmer.nb function. The first model denoted by â€œmodel.itn.timeâ€œ will incorporate a response variable which is mosquito counts denoted by â€œmosquito.countâ€, fixed effects which are ITN, time and random effects based on chambers and time. The second model called â€œmodel.itnâ€ obtained by updating the model â€œmodel.itn.timeâ€ using the update() function by opting out the term â€œitn:timeâ€. Extract p-values by comparing the two models using anova() function.

```{r}
    # outputting the parameter estimates and the p-values 
      model.itn.time <- glmer.nb(mosquito.count ~ itn*time + (1|chamber)+(1|timef),data=dat)
      model.itn <- update(model.itn.time, ~.-itn:time)
      p <- anova(model.itn.time,model.itn)[2, "Pr(>Chisq)"]    
      c(p = p)
```

iv)	Power estimation for a single data set 

In sub-sections (i-iii), we illustrated how to simulate and calculate a p-value for a single data. Since we canâ€™t learn anything from a single simulation for power estimation, therefore, we need to simulate multiple data sets as shown in subsequent sections (v-vii). 

v)	Simulation of the multiple data sets.

A function called â€œsim.dat.funâ€ was created to automate the simulation process described in sub-section (ii) above. The "sim.dat.fun" function takes a design table â€œdatâ€, coefficients â€œb.0â€, â€œb.iâ€, â€œb.i.tâ€, and inter-chamber variance â€œchamber.varâ€ and time variance â€œtime.varâ€ as input parameters. The function then produces a table â€œdatâ€ containing mosquito counts as an output.

```{r}
    # function for simulating the data
    # assign function to simulate data as sim.dat.fun
    # beginning of the function "sim.dat.fun"
    sim.dat.fun <- function(dat,b.0,b.i,b.i.t,chamber.var,time.var, theta){
      # simulate random effects
      # random effect between chambers
      chamber.re <- rnorm(nlevels(dat$chamber), sd = sqrt(chamber.var))
      names(chamber.re) <- levels(dat$chamber)
      # random effect between time (e.g., between weeks)
      time.re <- rnorm(nlevels(dat$timef), sd = sqrt(time.var))
      names(time.re) <- levels(dat$timef)
      # simulate linear predictor (with fixed effects only)
      # add the simulated data to dataset "dat" as a column named lin.pred
      dat$lin.pred.fixed <-
        b.0 +  b.i * dat$itn + b.i.t*dat$itn.time 
      # add random effects (chamber.re and time.re) to linear predictors trials, mean and size
      dat$lin.pred <-
        dat$lin.pred.fixed +
        chamber.re[as.character(dat$chamber)] +
        time.re[as.character(dat$timef)]
      # generate mosquitoes counts as random data using NB with number of    
      dat$mosquito.count <- rnbinom(nrow(dat), mu = exp(dat$lin.pred), size = theta)
      dat
    } # end of data simulation function "sim.dat.fun"
    # assigh the function as simdat for easy referencing 
    simdat <- sim.dat.fun(dat,b.0,b.i,b.i.t,chamber.var,time.var, theta)
    # output the â€œsimdatâ€
    simdat
```

You can produce a time series plot of the mosquito data generated by a function assigned as â€œsimdatâ€. You can plot mosquito counts without and with random effects. Here is how to produce plots for mosquito count excluding random effects. 

```{r}
  simdat.treatment <- simdat %>% mutate(Treatments=case_when(itn==0 ~ "Control",
                                                             itn==1 ~ "ITN"))

      # plot mosquito counts data without random effects (i.e., the linear predictor with fixed effects)
      ggplot(simdat.treatment,aes(x=factor(time*12),y=exp(lin.pred.fixed), group=chamber, col=Treatments)) +
        geom_line()+
        geom_point()+
        labs(x = "Time (Weeks)", y = "Mosquito counts") +
        scale_color_manual(values=c("black", "red"))+
        scale_y_continuous(limits=c(0,40.5))+
        theme_bw()
```

vi)	Perform a statistical test for the simulated data sets to extract p-values.

In this case, a function called â€œsim.mos.pvalâ€ was created to automate the function â€œsim.dat.funâ€ and outputs p-values. The function â€œsim.mos.pvalâ€ will output the p-values from the GLMM model with a negative binomial distribution. The fitted model denoted by â€œmodel.itn.timeâ€ will incorporate a response variable which is the expected mosquito counts denoted by â€œmosquito.countâ€, fixed effects which are ITN, time and their interactions and random effects between chambers and time. Another model namely â€œmodel.itnâ€ will contain the same terms as â€œmodel.itnâ€ but without an interaction term. 

```{r}
    # outputting the parameter estimates and the p-values from the simulation function
    sim.mos.pval <- function(...){
      simdat2 <- sim.dat.fun(dat,b.0,b.i,b.i.t,chamber.var,time.var, theta)
      model.itn.time <- glmer.nb(mosquito.count ~ itn*time + (1|chamber)+(1|timef),data=simdat2)
      model.itn <- update(model.itn.time, ~.-itn:time)
      p <- anova(model.itn.time,model.itn)[2, "Pr(>Chisq)"]    
      c(p = p)
    }
```

vii)	Power estimation for multiple data sets
Here, we created a function â€œsim.pvals.listâ€ to output power estimate by updating function â€œsim.mos.pvalâ€ multiple times based on the number of simulations â€œnsimâ€ provided. Again, we created another function called â€œsim.pvals.listâ€ that will output a list of p-values by updating the function â€œsim.mos.pvalâ€ to simulate multiple data sets based on the number of simulations â€œnsimâ€ assigned. 
Notes: nsim is set to 100 for illustration purpose. However, we recommend setting nsim to a much higher value, e.g., 1000.

```{r}
    nsim <- 100
    set.seed(1234)
    sim.pvals.list <- lapply(1:nsim, sim.mos.pval)
    sim.pvals <- do.call("rbind", sim.pvals.list)
    # return power estimates
    n.sig <- sum(sim.pvals[, "p"] < 0.05)
    power.estimate <- round((n.sig/nsim),2)
    power.estimate
```

viii) Warnings 

Typically, there is one common warning that may occur when running this tutorial namely "model convergence warning". Here, there is no any warning out of 100 runs, which is good but it is important knowing how to deal with it when it occurs. One can ignore this warning as it does not affect the results. However, it is important for readers to know why this warning occurs and how to deal with it. One of the common reason for the convergence warning to occur is because the model is too complex for the given data set. This means that there is no much data for a given statistical model. For example, two chambers for single intervention results to four rows of a data set, which may not be enough to use statistical test. This warning can be addressed by changing the optimizer (i.e., control = glmerControl(optimizer = "bobyqa")) and comparing the likelihood with and without changing the optimizer.
