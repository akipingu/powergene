---
title: "A power analysis framework to design robust semi-field vector control experiments: \n Power analysis R tutorial for long-term SFE testing combined interventions"
author: "Kipingu AM, Lwetoijera DW, Ng'habi K, Kiware SS, Viana M, Johnson PCD"
date: "`r Sys.Date()`"
output: html_document
fontsize: 12pt
---

Set libraries
```{r}
library(ggplot2) # for ggplot
library(lme4) # for glmer
library(dplyr) # case_when function
```

set seed
```{r}
# helps to give same result every time one run the code. You can choose to disable it
set.seed(123)  
```

Notes: simulation of data sets consists of different experimental design scenarios intended to be test. In our case, we consider number of chambers per treatment (â€œn.ch.per.trtâ€), which is 4; frequency of sampling ("sampl.freqâ€), which is 12 corresponds to weekly sampling; number of mosquitoes to be sampled or released (â€œlambdaâ€), which is 10; proportion of mosquitoes remaining over time due to PPFa alone (â€œppf.timeâ€), which is 0.3;  proportion of mosquitoes remain over time due to ITN alone â€œitn.timeâ€, which is 0.2; proportion of mosquitoes remain over time due to interaction between ITN and PPFa (â€œixn.ppf.itn.timeâ€), which is 0.2; inter-chamber variance (â€œchamber.varâ€), which is 0.1807; time variance (â€œtime.var), which is 0.2266; dispersion parameter (â€œthetaâ€), which is 10; and total number of simulations (â€œnsimâ€), which is 100 for this tutorial. 

i)	The setting of experimental design scenarios and parameter choices in R

Set and assign an experimental design choices based on the number of chambers per treatment, sampling frequency and interventions levels. Make a template data set called â€œdatâ€ representing the design. 

```{r}
    # design choices
    n.ch.per.trt <- 4
    sampl.freq <- 12 # weekly sampling, which 12 sampling points in 3 months. 
    ppf.lev <- 0:1 # 0 means no ppf and 1 means there's PPFa
    itn.lev <- 0:1 # 0 means no itn and 1 means there's ITN
    
    # make template data set representing the design 
    dat <-
      expand.grid(replicates = 1:n.ch.per.trt, ppf = ppf.lev, itn = itn.lev, time = (0:sampl.freq)/sampl.freq)
    dat$ixn.pit <- dat$ppf * dat$itn * dat$time # interaction between PPFa, ITN and time
    dat$ixn.pt <- dat$ppf * dat$time # interaction between PPFa and time
    dat$ixn.it <- dat$itn * dat$time # interaction between ITN and PPFa
    # create chambers/replicates ID e.g., 1-1-2 means chamber number 2 with both ITN and PPFa
    dat$chamber <- factor(paste(dat$ppf, dat$itn, dat$replicates, sep = "-")) 
    dat$timef <- factor(dat$time) # make time as factor to obtain levels
    # rearranging data set in a useful order
    dat <- dat[, c("replicates", "ppf", "itn", "time", "timef", "chamber", "ixn.pit", "ixn.pt", "ixn.it")]
    dat
```

Assign values for all parameters for fixed and random effects. The interventions effects here will change with time. Therefore, there will be an interaction between time and the interventions (i.e., ITN x Time, PPFa x Time and PPFa x ITN x Time). 

```{r}
    # parameter choices - fixed effects
    # mean catch mosquito count in control group
    lambda <- 40 
    # proportion of mosquitoes remains over time due to PPFa
    ppf.time <- 0.3 
    # proportion of mosquitoes remains overtime due to ITN
    itn.time <- 0.2
    # proportion of mosquitoes remains overtime due to ITN-PPFa interaction: 
    ixn.ppf.itn.time <- 0.5
    
    # parameter choices - random effects
    # variance/variability between chambers
    chamber.var <- 1.807e-01
    # variance/variability over time
    time.var <- 2.266e-01
    # theta is a over dispersion/variability parameter for negative binomial distribution 
    # measures how sample (i.e., mosquito counts in our case) fluctuates around the mean
    # theta is usually interpreted as a measure of overdispersion with respect to the Poisson distribution.       
    # the variance of the negative binomial is ğœ‡+ğœ‡2/ğœƒ, so ğœƒ really controls the excess variability compared to Poisson (which would be ğœ‡)
    theta <- 10
```

Calculate coefficients for all linear predictor terms using the log link function. We used the log link function because parameter of negative binomial distribution is non-negative. 

```{r}
    # coefficients (parameter values) for the linear predictor terms
    b.0 <- log(lambda) # intercept
    b.pt <- log(ppf.time) #  PPFa effect over time
    b.it <- log(itn.time) # ITN effect over time
    b.pit <- log(ixn.ppf.itn.time) # interaction effect over time
```

ii)	Simulation of a single data set. 
As we have already set our experimental design scenarios and parameter choices such as coefficients for linear predictors, inter-chamber variance and the dispersion parameter value, now we can simulate a single data set. This means we will first simulate the values for the linear predictor that will then generate the mosquito counts that would be expected if faced with our experimental scenario and parameter choices. Here, we also simulate random effects between chambers as well as linear predictors without and with random effects. Using the simulated linear predictors, expected mosquito counts will then be generated using a negative binomial distribution.

```{r}
      # simulate random effects
      chamber.re <- rnorm(nlevels(dat$chamber), sd = sqrt(chamber.var)) # random effect between chambers
      names(chamber.re) <- levels(dat$chamber)
      time.re <- rnorm(nlevels(dat$timef), sd = sqrt(time.var)) # random effect between times (e.g., weeks)
      names(time.re) <- levels(dat$timef)
      # simulate linear predictor (with fixed effects) and 
      # add the simulated data to data set "dat" as a column named lin.pred
      dat$lin.pred.fixed <-
        b.0 + b.pt * dat$ixn.pt + b.it * dat$ixn.it  + b.pit * dat$ixn.pit 
      # add random effects (chamber.re and week.re) to the linear predictor; 
      dat$lin.pred <- dat$lin.pred.fixed +
        chamber.re[as.character(dat$chamber)] +
        time.re[as.character(dat$timef)]
      # generate mosquitoes counts as random data using negative binomial with number of trials (total rows of "dat"), mean or mu (exponet of lin.pred) and size (theta)
      dat$mosquito.count <- rnbinom(nrow(dat), mu = exp(dat$lin.pred), size = theta)
      # output data table
      dat
```

iii)	Perform a statistical test using the simulated data sets. 

Fit the simulated data to the GLMM model using a glmer.nb function. The first model denoted by â€œfit.ixnâ€œ will incorporate a response variable which is mosquito counts denoted by â€œmosquito.countâ€, fixed effects which are ITN, PPFa and Time and random effects which are chambers and time denoted by â€œtimefâ€. The second model called â€œfit.noixnâ€ obtained by updating the model â€œfit.ixnâ€ using the update() function by opting out the term â€œppf:itn:timeâ€. extract p-values by comparing the two models using anova() function. 

```{r}
      # fitting the GLMM model "fit.ixn" by using the dataset dat; with ppf:itn:time interaction. 
      fit.ixn <- glmer.nb(mosquito.count ~ ppf*itn*time+(1|chamber)+(1|timef),data=dat)
      # fitting the GLMM model "fit.ixn" by using the dataset simdat2; with ppf:itn:time interaction. 
      # update fit.ixn by removing the ppf:itn:time interaction, the new model will be "fit.noixn." time in weeks so, it is ppf:itn:week
      fit.noixn <- update(fit.ixn, ~.-ppf:itn:time)
      # extract p-values by comparing the two models "fit.ixn" and "fit.noixn" by using anova
      p <- anova(fit.ixn,fit.noixn)[2, "Pr(>Chisq)"]
      # make p-vales as a column named p
      c(p = p)
```

iv)	Power estimation for a single data set 

In sub-sections (i-iii), we illustrated how to simulate and calculate a p-value for a single data. Since we canâ€™t learn anything from a single simulation for power estimation, therefore, we need to simulate multiple data sets as shown in subsequent sections (v-vii). 

v)	Simulation of the multiple data sets.

A function called â€œsim.dat.funâ€ was created to automate the simulation process described in sub-section (ii) above. The "sim.dat.fun" function takes a design table â€œdatâ€, coefficients â€œb.0â€, â€œb.ptâ€, â€œb.itâ€, â€œb.pitâ€, and inter-chamber variance â€œchamber.varâ€ and time variance â€œtime.varâ€ as input parameters. The function then produces a table â€œdatâ€ containing mosquito counts as an output.

```{r}
    # function for simulating the data
    # assign function to simulate data as sim.dat.fun
    # beginning of the function "sim.dat.fun"
    sim.dat.fun <- function(dat,b.0,b.pt,b.it,b.pit,chamber.var,time.var, theta){ 
      # simulate random effects
      chamber.re <- rnorm(nlevels(dat$chamber), sd = sqrt(chamber.var)) # random effect between chambers
      names(chamber.re) <- levels(dat$chamber)
      time.re <- rnorm(nlevels(dat$timef), sd = sqrt(time.var)) # random effect between times (e.g., weeks)
      names(time.re) <- levels(dat$timef)
      # simulate linear predictor (with fixed effects) and 
      # add the simulated data to dataset "dat" as a column named lin.pred
      dat$lin.pred.fixed <-
        b.0 + b.pt * dat$ixn.pt + b.it * dat$ixn.it  + b.pit * dat$ixn.pit 
      # add random effects (chamber.re and week.re) to the linear predictor; 
      dat$lin.pred <- dat$lin.pred.fixed +
        chamber.re[as.character(dat$chamber)] +
        time.re[as.character(dat$timef)]
      # generate mosquitoes counts as random data using negative binomial with number of trials (total rows of "dat"), mean or mu (exponet of lin.pred) and size (theta)
      dat$mosquito.count <- rnbinom(nrow(dat), mu = exp(dat$lin.pred), size = theta)
      #Output data table
      dat
    } #end of data simulating function
    # assign the function as simdat for easy referencing 
    simdat <- sim.dat.fun(dat,b.0,b.pt,b.it,b.pit,chamber.var,time.var, theta)
    # output the â€œsimdatâ€ table
    simdat
```

You can produce a time series plot of the mosquito data generated by a function assigned as â€œsimdatâ€. You can plot mosquito counts without and with random effects. Here is how to produce plots for mosquito count excluding random effects. 

```{r}
    simdat.treatment <- simdat %>% mutate(Treatments=case_when(ppf==0 & itn==0 ~ "Control",
                                                               ppf==0 & itn==1 ~ "ITN",
                                                               ppf==1 & itn==0~ "PPFa",
                                                               ppf==1 & itn==1~ "PPFa+ITN \n interaction"))

      # plot mosquito counts data without random effects (i.e., the linear predictor with fixed effects)
      ggplot(simdat.treatment,aes(x=factor(time*12),y=exp(lin.pred.fixed), group=chamber, col=Treatments)) +
        geom_line()+
        geom_point()+
        labs(x = "Time (Weeks)", y = "Mosquito counts") +
        scale_color_manual(values=c("black", "red", "blue", "purple"))+
        theme_bw()
      simdat.treatment
```

vi)	Perform a statistical test for the simulated data sets to extract p-values. 

In this case, a function called â€œsim.mos.pvalâ€ was created to automate the function â€œsim.dat.funâ€ and outputs p-values. The function â€œsim.mos.pvalâ€ will output the p-values from the GLMM model with a negative binomial distribution. The fitted model denoted by â€œfit.ixnâ€ will incorporate a response variable which is the expected mosquito counts denoted by â€œmosquito.countâ€, fixed effects which are ITN, PPFa time and their interactions and random effects between chambers and time. Another model namely â€œfit.noixnâ€ will contain the same terms as â€œfit.ixnâ€ but without an interaction term.

```{r}
    # outputting the parameter estimates and the p-values from the simulation function sim.mos.pval
    sim.mos.pval <- function(...){
      # assign the sim.dat.fun function to simdat2
      simdat2 <- sim.dat.fun(dat,b.0,b.pt,b.it,b.pit,chamber.var,time.var, theta)
      # fitting the GLMM model "fit.ixn" by using the dataset simdat2; with ppf:itn:time interaction. 
      fit.ixn <- glmer.nb(mosquito.count ~ ppf*itn*time+(1|chamber)+(1|timef),data=simdat2)
      # fitting the GLMM model "fit.ixn" by using the dataset simdat2; with ppf:itn:time interaction. 
      # update fit.ixn by removing the ppf:itn:time interaction, the new model will be "fit.noixn." time in weeks so, it is ppf:itn:week
      fit.noixn <- update(fit.ixn, ~.-ppf:itn:time)
      # extract p-values by comparing the two models "fit.ixn" and "fit.noixn" by using anova
      p <- anova(fit.ixn,fit.noixn)[2, "Pr(>Chisq)"]
      # make p-vales as a column named p
      c(p = p)
    }
```

vii)	Power estimation for multiple data sets

Here, we created a function â€œsim.pvals.listâ€ to output power estimate by updating function â€œsim.mos.pvalâ€ multiple times based on the number of simulations â€œnsimâ€ provided. Again, we created another function called â€œsim.pvals.listâ€ that will output a list of p-values by updating the function â€œsim.mos.pvalâ€ to simulate multiple data sets based on the number of simulations â€œnsimâ€ assigned. 
Notes: nsim is set to 100 for illustration purpose. However, we recommend setting nsim to a much higher value, e.g., 1000.

```{r}
    date()
    set.seed(1234)
    nsim <- 100
    sim.pvals.list <- lapply(1:nsim, sim.mos.pval)
    sim.pvals <- do.call("rbind", sim.pvals.list)
    # return power estimates
    n.sig <- sum(sim.pvals[, "p"] < 0.05)
    power.estimate <- round((n.sig/nsim),2)
    power.estimate
    date()
```

viii) Warnings 

Typically, there is one common warning that may occur when running this tutorial namely "model convergence warning". Here, there is single warning out of 100 runs, which should not affect power estimates but it is important knowing how to deal with it when it occurs. One can ignore this warning as it does not affect the results. However, it is important for readers to know why this warning occurs and how to deal with it. One of the common reason for the convergence warning to occur is because the model is too complex for the given data set. This means that there is no much data for a given statistical model. For example, two chambers for single intervention results to four rows of a data set, which may not be enough to use statistical test. This warning can be addressed by changing the optimizer (i.e., control = glmerControl(optimizer = "bobyqa")) and comparing the likelihood with and without changing the optimizer.
