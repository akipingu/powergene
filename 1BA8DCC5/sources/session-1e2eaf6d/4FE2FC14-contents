---
title: "A power analysis framework to design robust semi-field vector control experiments: \n Power analysis R tutorial for short-term SFE testing combined interventions"
author: "Kipingu AM, Lwetoijera DW, Ng'habi K, Kiware SS, Viana M, Johnson PCD"
date: "`r Sys.Date()`"
output: html_document
fontsize: 12pt
---

Set libraries
```{r}
library(lme4) # for glmer
```

set seed
```{r}
# helps to give same result every time one run the code. You can choose to disable it
set.seed(123)  
```

Notes: Simulation of data sets consists of different experimental design scenarios intended to be test. In this case study, we considered number of chambers per treatment (“n.ch.per.trt”), which can be 4; number of recaptured mosquitoes (“lambda”), which can be 50; proportion of mosquitoes remains due to ITN alone “itn.effect”, which is 0.2; proportion of mosquitoes remains due to PPFa alone (“ppf.effect”), which can be 0.3; proportion of mosquitoes remains due to interaction between ITN and PPFa (“ixn.effect”), which can be  0.2; inter-chamber variance (“chamber.var”), which can be 0.1807; and total number of simulations (“nsim”), which is 100 for this tutorial. 

i) The setting and assigning of experimental design scenarios and parameter choices i.e., number of chambers per treatment, sampling frequency, PPFa and ITN intervention level. Make a template data set called “dat” representing the design. 

```{r}
    # design choices
    n.ch.per.trt <- 4
    ppf.lev <- 0:1 
    itn.lev <- 0:1
    # make a template data set representing design 
    dat <-
      expand.grid(replicates = 1:n.ch.per.trt, ppf = ppf.lev, itn = itn.lev)
    dat$chamber <- factor(paste(dat$ppf, dat$itn, dat$replicates, sep = "-"))
    dat$ixn <- dat$ppf * dat$itn # interaction btn PPFa and ITN
    # rearranging data set in a useful order
    dat <- dat[, c("replicates", "ppf", "itn", "ixn", "chamber")]
    dat
```

Assign values for all parameters choices for fixed effects. 

```{r}
    # parameter choices - fixed effects
    # mean catch mosquito count in control group 
    lambda <- 100
    # proportions remaining in PPFa chambers due to ITN 
    ppf.effect <- 0.3
    # proportions remaining in ITN chambers due to ITN 
    itn.effect <- 0.2
    # assign chamber variance 
    chamber.var <- 1.807e-01
    # proportions remaining in interaction due to between ITN and PPFa 
    ixn.effect <- 0.5 
```

Calculate coefficients for all linear predictor terms using the log link function. The log link function was used because the parameter of the Poisson distribution (which is the mean mosquito abundance) must be non-zero and positive.

```{r}
    # coefficients (parameter values) for the linear predictor terms
    b.0 <- log(lambda)
    b.p <- log(ppf.effect)
    b.i <- log(itn.effect)
    b.pi <- log(ixn.effect)
```

ii) Simulation of single data set

As we have already set our experimental design scenarios and parameter choices such as coefficients for linear predictors, inter-chamber variance and the dispersion parameter value, now we can simulate a single data set. This means we will first simulate the values for the linear predictor that will then generate the mosquito counts that would be expected if faced with our experimental scenario and parameter choices. Here, we also simulate random effects between chambers as well as linear predictors without and with random effects. Using the simulated linear predictors, expected mosquito counts will then be generated using a Poisson distribution.


```{r}

      # simulate random effects for chambers
      chamber.re <- rnorm(nlevels(dat$chamber), sd = sqrt(chamber.var))
      names(chamber.re) <- levels(dat$chamber)
      # simulate linear predictor (with fixed effects only)
      # add the simulated data to dataset "dat" as a column named lin.pred
      dat$lin.pred.fixed <-
        b.0 + b.p * dat$ppf + b.i * dat$itn + b.pi * dat$ixn 
      # add random effects (chamber.re) to linear predictors trials, mean and size
      dat$lin.pred <-  
        dat$lin.pred.fixed + chamber.re[as.character(dat$chamber)] 
      # generate mosquitoes counts as random data using Poisson distribution   
      dat$mosquito.count <- rpois(nrow(dat), exp(dat$lin.pred))
      dat$ixn.effect <- dat$ixn.effect
      # output the new data table “dat”  
      dat
```


iii)	Perform a statistical test for a simulated data set to extract the p-value. 

Fitting the simulated data in “dat” to the GLMM model using a glmer function. The model named "fit.ixn" will incorporate a response variable which is the expected mosquito counts denoted by "mosquito.count", a fixed effect for a single and combined interventions and a random effect between chambers. The model named "fit.noixn" with single interventions only. From the models summaries, the p-value will be extracted by comparing the two models using anova() function.

```{r}
    # outputting the parameter estimates and the p-values 
      fit.ixn <- glmer(mosquito.count ~ ppf+itn+ixn+(1|chamber), family = "poisson", data=dat)
      fit.noixn <- glmer(mosquito.count ~ ppf+itn+(1|chamber),family = "poisson",data=dat)
      p <- anova(fit.ixn,fit.noixn)[2, "Pr(>Chisq)"]
      c(p = p)
```

iv)	Power estimation for a single data set 

In sub-sections (i-iii), an illustration of how to simulate and calculate a p-value for a single data was provided. Since one can’t learn anything from a single simulation for power estimation, therefore, there is a need to simulate multiple data sets as shown in subsequent sections (v-vii). 

v)	Simulation of the multiple data sets.

A function called “sim.dat.fun” was created to automate the simulation process described in sub-section (ii) above. The "sim.dat.fun" function takes a design table “dat”, coefficients “b.0”, “b.p”, “b.i” and “b.pi”, and inter-chamber variance “chamber.var” as input parameters. The function then produces a table “dat” containing mosquito counts as an output.  


```{r}
    # function for simulating the data
    # assign function to simulate data as sim.dat.fun
    # begining of the function "sim.dat.fun"
sim.dat.fun <- function(dat,b.0,b.p,b.i,b.pi,chamber.var){
      # simulate random effects for chambers
      chamber.re <- rnorm(nlevels(dat$chamber), sd = sqrt(chamber.var))
      names(chamber.re) <- levels(dat$chamber)
      # simulate linear predictor (with fixed effects only)
      # add the simulated data to dataset "dat" as a column named lin.pred
      dat$lin.pred.fixed <-
        b.0 + b.p * dat$ppf + b.i * dat$itn + b.pi * dat$ixn 
      # add random effects (chamber.re) to linear predictors trials, mean and size
      dat$lin.pred <-  
        dat$lin.pred.fixed + chamber.re[as.character(dat$chamber)] 
      # generate mosquitoes counts as random data using Poisson distribution    
      dat$mosquito.count <- rpois(nrow(dat), exp(dat$lin.pred))
      dat$ixn.effect <- dat$ixn.effect
      # output the new data table “dat”  
      dat
    } # end of data simulation function "sim.dat.fun"
    # assigh the function as simdat for easy referencing 
    simdat <- sim.dat.fun(dat,b.0,b.p,b.i,b.pi,chamber.var)
    # output the “simdat”
    simdat
```

vi)	Perform a statistical test for the simulated data sets to extract p-values.

In this case, a function called “sim.mos.pval” was created to automate the function “sim.dat.fun” and outputs p-values. The function “sim.mos.pval” will output the p-values from the GLMM model with a Poisson distribution. The fitted model denoted by “fit.ixn” will incorporate a response variable which is the expected mosquito counts denoted by “mosquito.count”, fixed effects which are ITN, PPFa and their interactions and a random effect between chambers. Another model namely “fit.noixn” will contain the same terms as “fit.ixn” but without an interaction term.
    
```{r}
    # outputting the parameter estimates and the p-values from the simulation function
    sim.mos.pval <- function(...){
      simdat2 <- sim.dat.fun(dat,b.0,b.p,b.i,b.pi,chamber.var)
      fit.ixn <- glmer(mosquito.count ~ ppf+itn+ixn+(1|chamber),family = "poisson",data=simdat2)
      fit.noixn <- glmer(mosquito.count ~ ppf+itn+(1|chamber),family = "poisson",data=simdat2)
      p <- anova(fit.ixn,fit.noixn)[2, "Pr(>Chisq)"]
      c(p = p)
    }
```

vii)	Power estimation for multiple data sets

Here, a function “sim.pvals.list” was created to output power estimate by updating function “sim.mos.pval” multiple times based on the number of simulations “nsim” provided. Again, another function called “sim.pvals.list” was created to output a list of p-values by updating the function “sim.mos.pval” to simulate multiple data sets based on the number of simulations “nsim” assigned. Therefore, the percentage of the data sets whose p-values are less than 0.05 is the power estimate. 
Notes: nsim is set to 100 for illustration purpose. However, we recommend setting nsim to a much higher value, e.g., 1000.

```{r}
date()
    nsim <- 100
    set.seed(1234)
    sim.pvals.list <- lapply(1:nsim, sim.mos.pval)
    sim.pvals <- do.call("rbind", sim.pvals.list)
    # return power estimates
    n.sig <- sum(sim.pvals[, "p"] < 0.05)
    power.estimate <- round((n.sig/nsim),2)
    power.estimate
    date()
```

viii) Warnings 

Typically, there are two common warnings that may occur when running this tutorial namely (a) model convergence warning and (b) boundary (singular) warning. Here, there is 4 warnings out of 100 runs, which should not affect power estimates but it worthy knowing how to deal with them. One can ignore these warning as they don not affect the results. However, it is important for readers to know why these warnings occur and how to deal with them. One of the common reason for the convergence warning to occur is because the model is too complex for the given data set. This means that there is no much data for a given statistical model. For example, two chambers for combined intervention results to six rows of a data set, which may not be enough to use statistical test. The boundary warning is usually caused by a variance estimate that is too small or zero. This warning can be addressed by changing the optimizer (i.e., control = glmerControl(optimizer = "bobyqa")) and comparing the likelihood with and without changing the optimizer.
