#' Simulate Design Scenarios for Short-Term Semi-Field Experiment Testing Combined Interventions
#'
#' Constructs a data frame representing the factorial design of semi-field experiments
#' testing intvn1 and intvn2 interventions. Each chamber is uniquely identified and assigned
#' treatment combinations, including interaction terms.
#'
#' @param n.ch.per.trt Integer. Number of chambers per treatment combination (default = 4).
#'
#' @return A data frame with columns:
#' \describe{
#'   \item{replicates}{Replicate number within each treatment combination}
#'   \item{intvn1}{intvn1a intervention level}
#'   \item{intvn2}{intvn2 intervention level}
#'   \item{ixn}{Interaction term: intvn1 × intvn2}
#'   \item{chamber}{Unique chamber identifier}
#' }
#' @examples
#' sim.scen.shortsfe.comint(n.ch.per.trt = 4)
#'
#' @export
sim.scen.shortsfe.comint <- function(n.ch.per.trt) {
# Expand factorial design
  dat <- expand.grid(replicates = 1:n.ch.per.trt,
                     intvn1 = 0:1,
                     intvn2 = 0:1)

  # Create unique chamber ID
  dat$chamber <- factor(paste(dat$intvn1, dat$intvn2, dat$replicates, sep = "-"))

  # Define interaction term
  dat$ixn <- dat$intvn1 * dat$intvn2

  # Reorder columns for clarity
  dat <- dat[, c("replicates", "intvn1", "intvn2", "ixn", "chamber")]

  return(dat)
}

#' Simulate Mosquito Count Data for Short-Term Semi-Field Experiment Testing Combined Interventions
#'
#' Generates simulated mosquito count data based on fixed effects (intervention levels),
#' random chamber effects, and a Poisson response model. This function is designed to
#' support empirical power analysis in semi-field experiments.
#'
#' @param n.ch.per.trt Integer. Number of chambers per treatment combination.
#' @param lambda Numeric. Mean mosquito count in control chambers.
#' @param intvn1.effect Numeric. Proportion reduction due to intervention 1.
#' @param intvn2.effect Numeric. Proportion reduction due to intervention 2.
#' @param ixn.effect Numeric. Proportion reduction due to interaction between interventions.
#' @param chamber.var Numeric. Variance of random chamber effects.
#'
#' @return A data frame with columns:
#' \describe{
#'   \item{replicates}{Replicate number within each treatment combination}
#'   \item{intvn1}{Intervention 1 level (0 or 1)}
#'   \item{intvn2}{Intervention 2 level (0 or 1)}
#'   \item{ixn}{Interaction term: intvn1 × intvn2}
#'   \item{chamber}{Unique chamber identifier}
#'   \item{lin.pred.fixed}{Linear predictor from fixed effects only}
#'   \item{lin.pred.random}{Linear predictor including random chamber effects}
#'   \item{mosquito.count}{Simulated mosquito counts from Poisson distribution}
#' }
#'
#' @examples
#' sim.mosq.shortsfe.comint(
#'   n.ch.per.trt = 4,
#'   lambda = 50,
#'   intvn1.effect = 0.7,
#'   intvn2.effect = 0.8,
#'   ixn.effect = 0.5,
#'   chamber.var = 0.1807
#' )
#'
#' @importFrom stats rnorm rpois
#' @export
sim.mosq.shortsfe.comint <- function(n.ch.per.trt, lambda, intvn1.effect, intvn2.effect, ixn.effect, chamber.var) {
  dat <- sim.scen.shortsfe.comint(n.ch.per.trt)

  # Convert intervention effects to log-scale coefficients
  b.0 <- log(lambda)
  b.intvn1 <- log(1 - intvn1.effect)
  b.intvn2 <- log(1 - intvn2.effect)
  b.ixn <- log(1 - ixn.effect)

  # Simulate random chamber effects
  chamber.re <- rnorm(nlevels(dat$chamber), sd = sqrt(chamber.var))
  names(chamber.re) <- levels(dat$chamber)

  # Compute fixed-effect linear predictor
  dat$lin.pred.fixed <- b.0 + b.intvn1 * dat$intvn1 + b.intvn2 * dat$intvn2 + b.ixn * dat$ixn

  # Add random chamber effects
  dat$lin.pred.random <- dat$lin.pred.fixed + chamber.re[as.character(dat$chamber)]

  # Simulate mosquito counts using Poisson model
  dat$mosquito.count <- rpois(nrow(dat), exp(dat$lin.pred.random))

  return(dat)
}

#' Extract p-value from Simulated GLMM for Short-Term Semi-Field Experiment Testing Combined Interventions
#'
#' Simulates mosquito count data under a factorial intervention design, fits two generalized linear mixed models (GLMMs),
#' and extracts the p-value for the interaction term via likelihood ratio test. This function supports empirical power analysis
#' by quantifying the statistical significance of combined intervention effects.
#'
#' @param n.ch.per.trt Integer. Number of chambers per treatment combination.
#' @param lambda Numeric. Mean mosquito count in control chambers.
#' @param intvn1.effect Numeric. Proportion reduction due to intervention 1.
#' @param intvn2.effect Numeric. Proportion reduction due to intervention 2.
#' @param ixn.effect Numeric. Proportion reduction due to interaction between interventions.
#' @param chamber.var Numeric. Variance of random chamber effects.
#'
#' @return A named numeric vector:
#' \describe{
#'   \item{p}{p-value from likelihood ratio test comparing models with and without the interaction term}
#' }
#'
#' @examples
#' sim.pval.shortsfe.comint(
#'   n.ch.per.trt = 4,
#'   lambda = 50,
#'   intvn1.effect = 0.7,
#'   intvn2.effect = 0.8,
#'   ixn.effect = 0.5,
#'   chamber.var = 0.1807
#' )
#'
#' @importFrom lme4 glmer
#' @importFrom stats anova
#' @export
sim.pval.shortsfe.comint <- function(n.ch.per.trt, lambda, intvn1.effect, intvn2.effect, ixn.effect, chamber.var) {
  # Simulate data
  simdat2 <- sim.mosq.shortsfe.comint(n.ch.per.trt, lambda, intvn1.effect, intvn2.effect, ixn.effect, chamber.var)

  # Fit GLMM with interaction
  fit.ixn <- suppressMessages(suppressWarnings(lme4::glmer(mosquito.count ~ intvn1 + intvn2 + ixn + (1 | chamber),
                         family = "poisson", data = simdat2)))

  # Fit GLMM without interaction
  fit.noixn <- suppressMessages(suppressWarnings(lme4::glmer(mosquito.count ~ intvn1 + intvn2 + (1 | chamber),
                           family = "poisson", data = simdat2)))

  # Extract p-value from likelihood ratio test
  pvalue <- stats::anova(fit.ixn, fit.noixn)[2, "Pr(>Chisq)"]

  return(c(pvalue = pvalue))
}

#' Estimate Empirical Power for Short-Term Semi-Field Experiment Testing Combined Intervention
#'
#' Runs repeated simulations and GLMM fits to estimate empirical power
#' as the proportion of simulations with p-values below 0.05.
#'
#' @param n.ch.per.trt Integer. Number of chambers per treatment level.
#' @param lambda Numeric. Mean mosquito count in control chambers.
#' @param intvn1.effect Numeric. Proportion reduction due to intervention 1.
#' @param intvn2.effect Numeric. Proportion reduction due to intervention 2.
#' @param ixn.effect Numeric. Proportion reduction due to interaction between interventions.
#' @param chamber.var Numeric. Variance of random chamber effects.
#' @param nsim Integer. Number of simulation replicates.
#' @param n.cores Integer. Number of cores to use for parallel processing.
#'
#' @return A named numeric vector:
#' \describe{
#'   \item{power}{Estimated empirical power (rounded to two decimal places)}
#'   \item{ci.lower}{Lower bound of 95\% confidence interval}
#'   \item{ci.upper}{Upper bound of 95\% confidence interval}
#' }
#'
#' @note Parallel execution is supported via `n.cores`, but examples default to `n.cores = 1` for reproducibility and package checks.
#'
#' @examples
#' sim.power.shortsfe.comint(
#'   n.ch.per.trt = 4,
#'   lambda = 50,
#'   intvn1.effect = 0.7,
#'   intvn2.effect = 0.8,
#'   ixn.effect = 0.5,
#'   chamber.var = 0.1807,
#'   nsim = 100,
#'   n.cores = 1
#' )
#'
#' @importFrom parallel makeCluster parLapply stopCluster clusterExport detectCores
#' @importFrom stats binom.test coef rnorm rpois
#'
#' @export
sim.power.shortsfe.comint <- function(n.ch.per.trt, lambda, intvn1.effect, intvn2.effect, ixn.effect, chamber.var, nsim,
                                      n.cores = 1) {

  # Define simulation wrapper
  sim_wrapper <- function(i) {
    result <- tryCatch(
      sim.pval.shortsfe.comint(n.ch.per.trt, lambda, intvn1.effect, intvn2.effect, ixn.effect, chamber.var),
      error = function(e) NA
    )
    result["pvalue"]
  }

  # Initialize progress bar
  pb <- utils::txtProgressBar(min = 0, max = nsim, style = 3)

  # Run simulations with progress
  if (n.cores > 1) {
    cl <- parallel::makeCluster(n.cores)
    on.exit(parallel::stopCluster(cl))
    parallel::clusterExport(cl, varlist = c("sim.pval.shortsfe.comint", "n.ch.per.trt",
                                            "lambda", "intvn1.effect", "intvn2.effect", "ixn.effect", "chamber.var"),
                            envir = environment())

    # Wrap with progress tracking
    pvals <- vector("list", nsim)
    for (i in seq_len(nsim)) {
      pvals[[i]] <- parallel::parLapply(cl, i, sim_wrapper)[[1]]
      utils::setTxtProgressBar(pb, i)
    }
  } else {
    pvals <- vector("list", nsim)
    for (i in seq_len(nsim)) {
      pvals[[i]] <- sim_wrapper(i)
      utils::setTxtProgressBar(pb, i)
    }
  }

  close(pb)

  # Flatten p-values and count significant results
  pvals <- unlist(pvals)
  n.sig <- sum(pvals < 0.05, na.rm = TRUE)

  # Estimate power and confidence interval
  power.estimate <- c(
    power = round(n.sig / nsim, 2),
    binom.test(x = n.sig, n = nsim)$conf.int
  )
  names(power.estimate)[2:3] <- c("ci.lower", "ci.upper")
  power.estimate
}
